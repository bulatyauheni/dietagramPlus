package bulat.diet.helper_ru.reciver;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Date;
import java.util.TreeMap;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.StatusLine;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.json.JSONArray;
import org.json.JSONObject;

import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.text.format.DateUtils;
import android.util.Log;
import bulat.diet.helper_ru.R;
import bulat.diet.helper_ru.activity.DietHelperActivity;
import bulat.diet.helper_ru.item.DishType;
import bulat.diet.helper_ru.utils.Constants;
import bulat.diet.helper_ru.utils.NetworkState;
import bulat.diet.helper_ru.utils.SaveUtils;

public class Recive extends BroadcastReceiver {
	public NotificationManager myNotificationManager;
	public static final int NOTIFICATION_ID = 1;
	public static final int NOTIFICATION_ID2 = 2;
	TreeMap<String,DishType> map = new TreeMap<String, DishType>();
	private boolean flagNotFirstTimeAdv=true;
	@Override
	public void onReceive(Context context, Intent intent) {
		Log.e("reciver", String.valueOf(SaveUtils.getUserAdvId(context)));
	    myNotificationManager = (NotificationManager) context.getSystemService(context.NOTIFICATION_SERVICE);

	      CharSequence NotificationTicket = context.getString(R.string.newmessage);
	      CharSequence NotificationTitle = context.getString(R.string.newmessage_title);
	     // CharSequence NotificationContent = "USB is Connected!";
	     
	      Date currDate = new Date();
    	  if(currDate.getTime() - SaveUtils.getLastVisitTime(context) > 2*DateUtils.DAY_IN_MILLIS && currDate.getTime() - SaveUtils.getLastVisitTime(context) < 3 * DateUtils.DAY_IN_MILLIS  && currDate.getTime() - SaveUtils.getLastNtifShownDate(context) > 0.5*DateUtils.DAY_IN_MILLIS){
    		  SaveUtils.setLastNtifShownDate(currDate.getTime(), context);
    		  Notification notification = new Notification(R.drawable.icon_m, NotificationTicket, 0);
		      Intent notificationIntent = new Intent(context, DietHelperActivity.class);
		      PendingIntent contentIntent = PendingIntent.getActivity(context, 0, notificationIntent, 0);
		      notification.setLatestEventInfo(context, context.getString(R.string.reminder), context.getString(R.string.reminder) , contentIntent);
		      notification.flags |= Notification.FLAG_AUTO_CANCEL;
		      myNotificationManager.notify(NOTIFICATION_ID2, notification);
    	  }
    	  if(currDate.getTime() - SaveUtils.getLastVisitTime(context) > 30*DateUtils.DAY_IN_MILLIS && currDate.getTime() - SaveUtils.getLastVisitTime(context) < 31 * DateUtils.DAY_IN_MILLIS  ){
    		  Notification notification = new Notification(R.drawable.icon_m, NotificationTicket, 0);
		      Intent notificationIntent = new Intent(context, DietHelperActivity.class);
		      PendingIntent contentIntent = PendingIntent.getActivity(context, 0, notificationIntent, 0);
		      notification.setLatestEventInfo(context, context.getString(R.string.reminder), context.getString(R.string.reminder) , contentIntent);
		      notification.flags |= Notification.FLAG_AUTO_CANCEL;
		      myNotificationManager.notify(NOTIFICATION_ID2, notification);
    	  }
	      if (0!=SaveUtils.getUserUnicId(context)) {
	    	
	      if(getMessages(context)){
		      StringBuilder message = new StringBuilder();
		      for (DishType dt : map.values()) {
		    	  message.append(dt.getDescription() + " (" + dt.getTypeKey() + ") " );
		      }
		      Notification notification = new Notification(R.drawable.icon_m, NotificationTicket, 0);
		      Intent notificationIntent = new Intent(context, DietHelperActivity.class);
		      PendingIntent contentIntent = PendingIntent.getActivity(context, 0, notificationIntent, 0);
		      notification.setLatestEventInfo(context, NotificationTitle, message , contentIntent);
		      notification.flags |= Notification.FLAG_AUTO_CANCEL;
		      myNotificationManager.notify(NOTIFICATION_ID, notification);
	      }
	     }
	}

	private boolean getMessages(Context context) {
		if (NetworkState.isOnline(context)) {
			StringBuilder builder = new StringBuilder();
			HttpParams httpParameters = new BasicHttpParams();
			// Set the timeout in milliseconds until a connection is established.
			// The default value is zero, that means the timeout is not used. 
			int timeoutConnection = 5000;
			HttpConnectionParams.setConnectionTimeout(httpParameters, timeoutConnection);
			int timeoutSocket = 10000;
			HttpConnectionParams.setSoTimeout(httpParameters, timeoutSocket);
			HttpClient client = new DefaultHttpClient(httpParameters);
			// searchString = searchString.replaceAll(" ", "%20");
			StringBuffer parametersb = new StringBuffer("");
			parametersb.append("?check_new_messages=" + SaveUtils.getUserUnicId(context));
			HttpGet httpGet = new HttpGet(Constants.URL_SOCIAL + parametersb);
			try {
				HttpResponse response = client.execute(httpGet);
				StatusLine statusLine = response.getStatusLine();
				int statusCode = statusLine.getStatusCode();
				if (statusCode == 200) {
					HttpEntity entity = response.getEntity();
					InputStream content = entity.getContent();
					BufferedReader reader = new BufferedReader(
							new InputStreamReader(content));
					String line;
					while ((line = reader.readLine()) != null) {
						builder.append(line);
					}
				} else {
					return false;
				}
				String resultString = builder.toString().trim();
				try {
					
					JSONObject jsonRoot = new JSONObject(resultString);
					JSONArray jsonArray = new JSONArray(
							jsonRoot.getString("updates"));
					
					for (int i = 0; i < jsonArray.length(); i++) {						
						JSONObject jsonObject = jsonArray.getJSONObject(i);
						//fullCount = fullCount +	Integer.parseInt(jsonObject.getString("count"));
						map.put(jsonObject.getString("user_from_id"),
								new DishType(
										Integer.parseInt(jsonObject.getString("count")), 
										jsonObject.getString("user_name")));
					}
					//SaveUtils.saveNewMessagesCount();
				} catch (Exception e) {
					e.printStackTrace();
				}
			} catch (ClientProtocolException e) {
				e.printStackTrace();
			} catch (IOException e) {
				e.printStackTrace();
			}
			if(map.size() < 1){
				return false;
			}
		} else {
			// set flag that app need update profile when network will
			// be available
			return false;
		}
		return true;
	}	

	
}
